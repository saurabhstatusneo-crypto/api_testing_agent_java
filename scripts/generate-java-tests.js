const fs = require("fs");
const path = require("path");

// --- Step 1: Utility to parse Java files dynamically ---
function analyzeJavaFile(filePath) {
    const content = fs.readFileSync(filePath, "utf8");
    const packageMatch = content.match(/package\s+([\w\.]+);/);
    const classMatch = content.match(/public\s+(?:class|interface|enum)\s+(\w+)/);
    const annotationMatch = content.match(/@\w+/g) || [];
    const methodRegex = /(public|protected|private)\s+([\w<>]+)\s+(\w+)\s*\(([^)]*)\)/g;

    const methods = [...content.matchAll(methodRegex)].map(m => ({
        visibility: m[1],
        returnType: m[2],
        name: m[3],
        params: m[4]
            .split(",")
            .map(p => p.trim())
            .filter(Boolean)
    }));

    return {
        packageName: packageMatch ? packageMatch[1] : "default",
        className: classMatch ? classMatch[1] : path.basename(filePath, ".java"),
        annotations: annotationMatch,
        methods
    };
}

// --- Step 2: Determine class type (service, controller, etc.) ---
function getClassType(info) {
    const pkg = info.packageName.toLowerCase();
    const annots = info.annotations.join(" ").toLowerCase();

    if (pkg.includes("controller") || annots.includes("controller")) return "controller";
    if (pkg.includes("service") || annots.includes("service")) return "service";
    if (pkg.includes("repository") || annots.includes("repository")) return "repository";
    return "general";
}

// --- Step 3: Dynamic test generator ---
function generateTests(info) {
    let tests = "";

    for (const method of info.methods) {
        if (method.name === info.className) continue; // skip constructor

        // Generate argument placeholders based on parameter types
        const args = method.params
            .map((p, i) => {
                if (p.includes("int")) return `${i + 1}`;
                if (p.includes("double")) return `${(i + 1) * 1.5}`;
                if (p.includes("boolean")) return "true";
                if (p.includes("String")) return `"value${i + 1}"`;
                return "null";
            })
            .join(", ");

        // Basic heuristic for AI-like logic
        let assertions = "";
        const mName = method.name.toLowerCase();

        if (["add", "sum", "plus"].some(k => mName.includes(k))) {
            assertions = `
        assertEquals(5, obj.${method.name}(2, 3));`;
        } else if (["subtract", "minus"].some(k => mName.includes(k))) {
            assertions = `
        assertEquals(1, obj.${method.name}(3, 2));`;
        } else if (["multiply", "times"].some(k => mName.includes(k))) {
            assertions = `
        assertEquals(6, obj.${method.name}(2, 3));`;
        } else if (mName.includes("divide")) {
            assertions = `
        assertEquals(2.0, obj.${method.name}(6, 3));
        assertThrows(IllegalArgumentException.class, () -> obj.${method.name}(5, 0));`;
        } else if (mName.startsWith("get") || mName.startsWith("is")) {
            assertions = `
        assertNotNull(obj.${method.name}(${args}));`;
        } else if (method.returnType === "void") {
            assertions = `
        obj.${method.name}(${args});
        assertTrue(true); // no exception expected`;
        } else {
            assertions = `
        var result = obj.${method.name}(${args});
        assertNotNull(result);`;
        }

        tests += `
    @Test
    void ${method.name}_autoGeneratedTest() {
        ${info.className} obj = new ${info.className}();${assertions}
    }`;
    }

    return tests;
}

// --- Step 4: Generate test file content dynamically ---
function buildTestFile(info) {
    const testBody = generateTests(info);
    return `
package ${info.packageName};

import ${info.packageName}.${info.className};
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ${info.className}Test {${testBody}
}
`;
}

// --- Step 5: File output preserving structure ---
function writeTestFile(info) {
    const testDir = path.join("src", "test", "java", ...info.packageName.split("."));
    fs.mkdirSync(testDir, { recursive: true });
    const testPath = path.join(testDir, `${info.className}Test.java`);
    fs.writeFileSync(testPath, buildTestFile(info));
    console.log(`✅ Generated test for ${info.className} (${info.packageName})`);
}

// --- Step 6: Recursively scan Java files ---
function processJavaFiles(dir) {
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) processJavaFiles(fullPath);
        else if (entry.name.endsWith(".java")) {
            const info = analyzeJavaFile(fullPath);
            writeTestFile(info);
        }
    }
}

// --- Step 7: Run ---
processJavaFiles(path.join("src", "main", "java"));
console.log("\n✅ All dynamic AI-based test cases generated.");
